# 匯入必要的模組
from absl import app
from pysc2.env import sc2_env
from pysc2.lib import actions, features, units
import numpy as np
import random  # 新增 random 模組

# === 核心定義區塊 (Protoss) ===
PROBE_TARGET = 15 

# 神族單位 ID
NEXUS_ID = 59 
PYLON_ID = 60
ASSIMILATOR_ID = 61      # 瓦斯處理廠
GATEWAY_ID = 62          # 傳送門
CYBERNETICS_CORE_ID = 72 # 機械控制核心
STALKER_ID = 74          # 追獵者
GEYSER_ID = 342          # 瓦斯噴泉 (Simple64 地圖通常是 ID 342)
MINERAL_FIELD_ID = 341

# 人族單位 ID (新增)
COMMAND_CENTER_ID = 18
SUPPLY_DEPOT_ID = 19
REFINERY_ID = 20
BARRACKS_ID = 21         # 兵營
BARRACKS_TECHLAB_ID = 37 # 兵營科技實驗室 (新增)
SCV_ID = 45
MARAUDER_ID = 51         # 掠奪者 (人族對應追獵者的單位)

# 神族動作 ID
BUILD_PYLON_ACTION = actions.FUNCTIONS.Build_Pylon_screen.id
BUILD_ASSIMILATOR_ACTION = actions.FUNCTIONS.Build_Assimilator_screen.id
BUILD_GATEWAY_ACTION = actions.FUNCTIONS.Build_Gateway_screen.id 
BUILD_CYBERNETICS_CORE_ACTION = actions.FUNCTIONS.Build_CyberneticsCore_screen.id 
TRAIN_PROBE_ACTION = actions.FUNCTIONS.Train_Probe_quick.id
TRAIN_STALKER_ACTION = actions.FUNCTIONS.Train_Stalker_quick.id 

# 人族動作 ID (新增)
BUILD_SUPPLYDEPOT_ACTION = actions.FUNCTIONS.Build_SupplyDepot_screen.id
BUILD_REFINERY_ACTION = actions.FUNCTIONS.Build_Refinery_screen.id
BUILD_BARRACKS_ACTION = actions.FUNCTIONS.Build_Barracks_screen.id
BUILD_TECHLAB_ACTION = actions.FUNCTIONS.Build_TechLab_quick.id # 修正：使用通用 TechLab 建造指令
TRAIN_SCV_ACTION = actions.FUNCTIONS.Train_SCV_quick.id
TRAIN_MARAUDER_ACTION = actions.FUNCTIONS.Train_Marauder_quick.id 
MOVE_CAMERA_ACTION = actions.FUNCTIONS.move_camera.id 

# 通用動作 ID
HARVEST_ACTION = actions.FUNCTIONS.Harvest_Gather_screen.id 
NO_OP = actions.FUNCTIONS.no_op()

class ProtossBot:
    """神族自動化機器人邏輯封裝"""
    def __init__(self):
        # 初始化該機器人的獨立狀態
        self.state = -1
        self.pylon_target_a = None 
        self.pylon_target_b = None
        self.assimilator_target = None   # 儲存第一個瓦斯噴泉座標
        self.assimilator_target_2 = None # 儲存第二個瓦斯噴泉座標
        self.gas_probes_assigned = 0     # 新增：已指派採瓦斯的探機數量
        self.selecting_probe = True      # 新增：控制是否正在選取探機的標記
        self.recent_selected_coords = [] # 修改：改為列表，記錄近期所有被選取過的探機位置
        self.stalkers_trained = 0        # 新增：已訓練的追獵者數量
        self.select_attempts = 0 
        self.initial_mineral_coords = None
        self.nexus_x_screen = 0
        self.nexus_y_screen = 0
        self.enemy_minimap_coords = None
        self.own_minimap_coords = None

        
        # 用於判斷是否剛初始化過 (第一幀)
        self.is_first_step = True

    def step(self, obs):
        """接收觀察值 (obs)，返回一個動作 (FunctionCall)"""
        
        # 1. 取得畫面資訊
        unit_type_screen = obs.observation.feature_screen[features.SCREEN_FEATURES.unit_type.index]
        current_supply_cap = obs.observation.player.food_cap
        current_minerals = obs.observation.player.minerals
        current_vespene = obs.observation.player.vespene # 新增：瓦斯資源
        current_workers = obs.observation.player.food_workers
        
        # --- minimap 上找自己跟敵人的位置 ---
        player_relative_mini = obs.observation.feature_minimap[features.MINIMAP_FEATURES.player_relative.index]
        y_self, x_self = (player_relative_mini == features.PlayerRelative.SELF).nonzero()
        if x_self.any():
            self.own_minimap_coords = (int(x_self.mean()), int(y_self.mean()))

        y_enemy, x_enemy = (player_relative_mini == features.PlayerRelative.ENEMY).nonzero()
        if x_enemy.any():
            self.enemy_minimap_coords = (int(x_enemy.mean()), int(y_enemy.mean()))

        # --- 輔助函式 (定義在 step 內以方便使用 local 變數) ---
        def unit_exists(unit_id):
            y_coords, x_coords = (unit_type_screen == unit_id).nonzero()
            return x_coords.any()

        def count_units(unit_id):
            return np.sum((unit_type_screen == unit_id).astype(int))

        # 搜尋並回傳選取 Nexus 的動作 (若沒選到)
        def get_select_nexus_action():
            y_coords, x_coords = (unit_type_screen == NEXUS_ID).nonzero()
            if x_coords.any():
                # 修改：使用 mean() 取得主堡的「中心點」，而非左上角
                target_x = int(x_coords.mean())
                target_y = int(y_coords.mean())
                
                # 保存 Nexus 座標供後續建築使用
                self.nexus_x_screen = target_x
                self.nexus_y_screen = target_y
                
                # 簡單選取一個矩形範圍確保選中
                x_start = max(0, target_x - 5)
                y_start = max(0, target_y - 5)
                x_end = min(83, target_x + 5)
                y_end = min(83, target_y + 5)
                return actions.FUNCTIONS.select_rect("select", (x_start, y_start), (x_end, y_end))
            return NO_OP

        # 搜尋並回傳選取 Probe 的動作
        def get_select_probe_action(select_type="select"):
            y_coords, x_coords = (unit_type_screen == 84).nonzero() # Probe ID
            if x_coords.any():
                # 選取第一隻找到的探機
                target_x, target_y = x_coords[0], y_coords[0] 
                return actions.FUNCTIONS.select_point(select_type, (target_x, target_y))
            return NO_OP

        # 搜尋並回傳選取 Gateway 的動作
        def get_select_gateway_action():
            y_coords, x_coords = (unit_type_screen == GATEWAY_ID).nonzero()
            if x_coords.any():
                target_x = int(x_coords.mean())
                target_y = int(y_coords.mean())
                return actions.FUNCTIONS.select_point("select", (target_x, target_y))
            return NO_OP
        
        def select_all_army():        
            player_relative_screen = obs.observation.feature_screen[features.SCREEN_FEATURES.player_relative.index]
            ys, xs = (player_relative_screen == features.PlayerRelative.SELF).nonzero()
            if xs.any():
                x_min, x_max = int(xs.min()), int(xs.max())
                y_min, y_max = int(ys.min()), int(ys.max())
                return actions.FUNCTIONS.select_rect("select", (x_min, y_min), (x_max, y_max))
            return NO_OP

        # --- 遊戲開始初始化 ---
        if self.is_first_step:
            self.is_first_step = False
            # 尋找礦物位置
            mineral_coords = (unit_type_screen == MINERAL_FIELD_ID).nonzero()
            if mineral_coords[0].any():
                self.initial_mineral_coords = (mineral_coords[1][0], mineral_coords[0][0])
            
            # 更新 Nexus 座標
            nexus_coords = (unit_type_screen == NEXUS_ID).nonzero()
            if nexus_coords[0].any():
                self.nexus_x_screen = nexus_coords[1].mean().astype(int)
                self.nexus_y_screen = nexus_coords[0].mean().astype(int)

        # --- 狀態機邏輯 ---
        
        if self.state == -1:
            # 狀態 -1: 選取全體探機去採礦
            # 這裡我們分兩步：1. 檢查是否能採礦 2. 不能則選取
            
            # 如果已經選取了單位且可以採礦
            if HARVEST_ACTION in obs.observation.available_actions and self.initial_mineral_coords:
                self.state = 0
                return actions.FUNCTIONS.Harvest_Gather_screen("now", self.initial_mineral_coords)
            else:
                # 嘗試選取所有探機
                return get_select_probe_action("select_all_type")

        elif self.state == 0:
            # 狀態 0: 生產探機直到 15 隻
            if current_workers < PROBE_TARGET:
                if TRAIN_PROBE_ACTION in obs.observation.available_actions:
                    if current_minerals >= 50:
                        return actions.FUNCTIONS.Train_Probe_quick("now")
                elif current_minerals >= 50:
                    # 資源夠但沒選項 -> 選主堡
                    return get_select_nexus_action()
            
            # 判斷是否進入下一階段 (工人大於等於目標 且 錢夠蓋塔)
            elif current_workers >= PROBE_TARGET and current_minerals >= 100:
                # 計算 Pylon 座標
                if self.nexus_x_screen != 0: 
                    # === 新增：動態計算建築位置 ===
                    # 1. 找出當前畫面中所有礦物的中心點
                    min_y_all, min_x_all = (unit_type_screen == MINERAL_FIELD_ID).nonzero()
                    if min_x_all.any():
                        mineral_mean_x = min_x_all.mean()
                        mineral_mean_y = min_y_all.mean()
                    else:
                        # 萬一沒看到礦，就用初始記錄的
                        mineral_mean_x, mineral_mean_y = self.initial_mineral_coords
                    
                    # 2. 計算從礦物指向主堡的方向 (遠離礦區)
                    diff_x = self.nexus_x_screen - mineral_mean_x
                    diff_y = self.nexus_y_screen - mineral_mean_y
                    
                    # 3. 根據方向決定偏移量 (往礦區的反方向蓋)
                    # 如果礦在左邊 (diff_x > 0)，我們往右蓋 (+15)
                    # 如果礦在右邊 (diff_x < 0)，我們往左蓋 (-15)
                    offset_x = 20 if diff_x > 0 else -20
                    offset_y = 20 if diff_y > 0 else -20
                    
                    # 設定 Pylon A 座標 (背對礦區)
                    self.pylon_target_a = (
                        np.clip(self.nexus_x_screen + offset_x, 0, 83).astype(int),
                        np.clip(self.nexus_y_screen + offset_y, 0, 83).astype(int)
                    )
                    
                    # 設定 Pylon B 座標 (稍微錯開一點，例如只改變 X 軸偏移)
                    self.pylon_target_b = (
                        np.clip(self.nexus_x_screen + offset_x * 0.5, 0, 83).astype(int),
                        np.clip(self.nexus_y_screen + offset_y * 1.5, 0, 83).astype(int)
                    )

                    self.state = 1
                    print(f"[{self}] 進入狀態 1: 準備建造 Pylon A (目標: {self.pylon_target_a})")
                else:
                    return get_select_nexus_action() # 重新抓取座標

        elif self.state == 1:
            # 狀態 1: 建造 Pylon A
            if BUILD_PYLON_ACTION in obs.observation.available_actions:
                self.state = 1.1
                self.select_attempts = 0
                return actions.FUNCTIONS.Build_Pylon_screen("now", self.pylon_target_a)
            else:
                return get_select_probe_action()

        elif self.state == 1.1:
            # 狀態 1.1: 等待 Pylon A 完成 (用人口上限判斷)
            if current_supply_cap >= 21:
                self.state = 1.2
                self.select_attempts = 0
                print(f"[{self}] Pylon A 完成，進入狀態 1.2")
                return NO_OP
            
            # 簡單的超時重試機制
            self.select_attempts += 1
            if self.select_attempts > 20: # 等待太久，可能建造失敗
                self.state = 1 # 重試
                return NO_OP

        elif self.state == 1.2:
            # 狀態 1.2: 建造 Pylon B
            if BUILD_PYLON_ACTION in obs.observation.available_actions:
                if current_minerals >= 100:
                    self.state = 1.3
                    self.select_attempts = 0
                    return actions.FUNCTIONS.Build_Pylon_screen("now", self.pylon_target_b)
            else:
                return get_select_probe_action()

        elif self.state == 1.3:
            # 狀態 1.3: 等待 Pylon B 完成
            if current_supply_cap >= 31:
                self.state = 2 # 進入狀態 2 (建造第一個瓦斯)
                print(f"[{self}] Pylon B 完成，進入狀態 2: 準備建造第一個 Assimilator")
                self.select_attempts = 0
                return NO_OP
            
            # 超時重試
            self.select_attempts += 1
            if self.select_attempts > 30:
                self.state = 1.2
                # 換個位置重試
                new_offset_x = -20 if (self.nexus_x_screen - self.pylon_target_b[0]) > 0 else 20
                self.pylon_target_b = (
                    np.clip(self.nexus_x_screen + new_offset_x, 0, 83).astype(int),
                    self.pylon_target_b[1]
                )
                return NO_OP

        elif self.state == 2:
            # 狀態 2: 建造第一個 Assimilator
            # 需要 75 礦
            if BUILD_ASSIMILATOR_ACTION in obs.observation.available_actions:
                if current_minerals >= 75:
                    # 尋找最近的瓦斯噴泉
                    if self.assimilator_target is None:
                        y_geo, x_geo = (unit_type_screen == GEYSER_ID).nonzero()
                        if x_geo.any():
                             # 優化：計算第一個瓦斯泉的「中心點」
                             # 1. 取出第一個點作為參考
                             first_x, first_y = x_geo[0], y_geo[0]
                             
                             # 2. 篩選出距離該點一定範圍內 (例如 10 像素) 的所有點，視為同一個湧泉
                             mask = (np.abs(x_geo - first_x) < 10) & (np.abs(y_geo - first_y) < 10)
                             
                             # 3. 計算這些點的平均值 (中心)
                             target_x = int(x_geo[mask].mean())
                             target_y = int(y_geo[mask].mean())
                             
                             self.assimilator_target = (target_x, target_y)
                             print(f"[{self}] 鎖定第一個瓦斯噴泉: {self.assimilator_target}")
                        else:
                             print(f"[{self}] 找不到瓦斯噴泉！")
                             return NO_OP 
                    
                    self.state = 2.1
                    self.select_attempts = 0
                    print(f"[{self}] 執行建造第一個 Assimilator")
                    return actions.FUNCTIONS.Build_Assimilator_screen("now", self.assimilator_target)
            else:
                # 如果動作不可用，選取探機
                return get_select_probe_action()
        
        elif self.state == 2.1:
            # 狀態 2.1: 等待第一個 Assimilator 完成 (只要有1個存在即可)
            if count_units(ASSIMILATOR_ID) >= 1:
                self.state = 3
                self.gas_probes_assigned = 0 # 歸零計數器
                self.selecting_probe = True  # 確保進入狀態3時先執行選取
                self.recent_selected_coords = [] # 清空歷史記錄
                print(f"[{self}] Assimilator 1 存在，進入狀態 3: 指派 3 隻探機採瓦斯")
                return NO_OP

            # 超時重試
            self.select_attempts += 1
            if self.select_attempts > 20:
                self.state = 2
                self.assimilator_target = None 
                return NO_OP

        elif self.state == 3:
            # 狀態 3: 指派 3 隻探機去採集第一個瓦斯
            if self.gas_probes_assigned < 3:
                # 使用 selecting_probe 旗標來強制交替
                if self.selecting_probe:
                    # 步驟 A: 隨機選取一隻探機 (加入位置過濾 + 避免重複選取)
                    y_coords, x_coords = (unit_type_screen == 84).nonzero() 
                    if x_coords.any():
                        # 計算每個探機距離目標瓦斯廠的距離
                        distances = np.sqrt((x_coords - self.assimilator_target[0])**2 + (y_coords - self.assimilator_target[1])**2)
                        
                        # 條件 1：距離瓦斯廠大於 15 (過濾掉已在工作的)
                        mask = distances > 15

                        # 條件 2：不屬於「近期已選取位置列表」中的任何點 (距離大於 8)
                        for past_x, past_y in self.recent_selected_coords:
                            dist_from_past = np.sqrt((x_coords - past_x)**2 + (y_coords - past_y)**2)
                            mask = mask & (dist_from_past > 8)
                        
                        if mask.any():
                            # 從符合條件的探機中選
                            valid_x = x_coords[mask]
                            valid_y = y_coords[mask]
                            idx = random.randint(0, len(valid_x) - 1)
                            target_x, target_y = valid_x[idx], valid_y[idx]
                        else:
                            # 萬一所有探機都不符合條件，只好從全部隨機選
                            idx = random.randint(0, len(x_coords) - 1)
                            target_x, target_y = x_coords[idx], y_coords[idx]
                        
                        # 記錄這次選取的座標到歷史列表
                        self.recent_selected_coords.append((target_x, target_y))
                        self.selecting_probe = False 
                        return actions.FUNCTIONS.select_point("select", (target_x, target_y))
                    return NO_OP
                else:
                    # 步驟 B: 下達採集指令
                    if HARVEST_ACTION in obs.observation.available_actions:
                        self.gas_probes_assigned += 1
                        self.selecting_probe = True 
                        print(f"[{self}] 指派探機 {self.gas_probes_assigned}/3 去瓦斯 1")
                        return actions.FUNCTIONS.Harvest_Gather_screen("now", self.assimilator_target)
                    else:
                        self.selecting_probe = True
                        return NO_OP
            else:
                # 指派完成，進入 State 4 (建造第二個瓦斯)
                self.state = 4
                self.select_attempts = 0
                self.recent_selected_coords = [] # 清空歷史記錄，準備下一輪
                print(f"[{self}] 瓦斯 1 採集指派完成，進入狀態 4: 準備建造第二個 Assimilator")
                return NO_OP

        elif self.state == 4:
            # 狀態 4: 建造第二個 Assimilator
            if BUILD_ASSIMILATOR_ACTION in obs.observation.available_actions:
                if current_minerals >= 75:
                    if self.assimilator_target_2 is None:
                        # 尋找第二個噴泉 (必須排除第一個)
                        y_geo, x_geo = (unit_type_screen == GEYSER_ID).nonzero()
                        if x_geo.any():
                            # 計算每個點與第一個目標的距離
                            first_tx, first_ty = self.assimilator_target
                            distances = np.sqrt((x_geo - first_tx)**2 + (y_geo - first_ty)**2)
                            
                            # 找出距離大於 15 的點 (視為不同的噴泉)
                            mask = distances > 15
                            
                            if mask.any():
                                target_x = int(x_geo[mask].mean())
                                target_y = int(y_geo[mask].mean())
                                self.assimilator_target_2 = (target_x, target_y)
                                print(f"[{self}] 鎖定第二個瓦斯噴泉: {self.assimilator_target_2}")
                            else:
                                print(f"[{self}] 找不到第二個瓦斯噴泉 (可能被遮擋或只有一個)")
                                return NO_OP
                        else:
                            return NO_OP
                    
                    self.state = 4.1
                    self.select_attempts = 0
                    print(f"[{self}] 執行建造第二個 Assimilator")
                    return actions.FUNCTIONS.Build_Assimilator_screen("now", self.assimilator_target_2)
            else:
                return get_select_probe_action()

        elif self.state == 4.1:
            # 狀態 4.1: 等待第二個 Assimilator 完成 (數量 >= 2)
            if count_units(ASSIMILATOR_ID) >= 2:
                self.state = 5
                self.gas_probes_assigned = 0 # 重置計數器
                self.selecting_probe = True  # 重置選取旗標
                self.recent_selected_coords = [] # 清空歷史記錄
                print(f"[{self}] Assimilator 2 存在，進入狀態 5: 指派 3 隻探機採瓦斯 2")
                return NO_OP
            
            self.select_attempts += 1
            if self.select_attempts > 20:
                self.state = 4
                self.assimilator_target_2 = None
                return NO_OP

        elif self.state == 5:
            # 狀態 5: 指派 3 隻探機去採集第二個瓦斯
            if self.gas_probes_assigned < 3:
                if self.selecting_probe:
                    # 步驟 A: 隨機選取 (加入雙重過濾 + 列表歷史過濾)
                    y_coords, x_coords = (unit_type_screen == 84).nonzero() 
                    if x_coords.any():
                        # 計算距離
                        dist1 = np.sqrt((x_coords - self.assimilator_target[0])**2 + (y_coords - self.assimilator_target[1])**2)
                        dist2 = np.sqrt((x_coords - self.assimilator_target_2[0])**2 + (y_coords - self.assimilator_target_2[1])**2)
                        
                        # 條件 1：同時遠離兩個瓦斯廠 (>15)
                        mask = (dist1 > 15) & (dist2 > 15)

                        # 條件 2：不屬於「近期已選取位置列表」中的任何點
                        for past_x, past_y in self.recent_selected_coords:
                            dist_from_past = np.sqrt((x_coords - past_x)**2 + (y_coords - past_y)**2)
                            mask = mask & (dist_from_past > 8)
                        
                        if mask.any():
                            valid_x = x_coords[mask]
                            valid_y = y_coords[mask]
                            idx = random.randint(0, len(valid_x) - 1)
                            target_x, target_y = valid_x[idx], valid_y[idx]
                        else:
                            # 萬一真的沒得選
                            idx = random.randint(0, len(x_coords) - 1)
                            target_x, target_y = x_coords[idx], y_coords[idx]

                        # 記錄這次選取的座標
                        self.recent_selected_coords.append((target_x, target_y))
                        self.selecting_probe = False 
                        return actions.FUNCTIONS.select_point("select", (target_x, target_y))
                    return NO_OP
                else:
                    # 步驟 B: 採集 (目標是第二個瓦斯廠)
                    if HARVEST_ACTION in obs.observation.available_actions:
                        self.gas_probes_assigned += 1
                        self.selecting_probe = True 
                        print(f"[{self}] 指派探機 {self.gas_probes_assigned}/3 去瓦斯 2")
                        return actions.FUNCTIONS.Harvest_Gather_screen("now", self.assimilator_target_2)
                    else:
                        self.selecting_probe = True
                        return NO_OP
            else:
                self.state = 6 # 修改：進入 State 6 (建造 Gateway)
                print(f"[{self}] 雙瓦斯採集指派完成，進入狀態 6: 準備建造傳送門")
                return NO_OP

        elif self.state == 6:
            # 狀態 6: 建造傳送門 (Gateway)
            # 需要 150 礦
            if BUILD_GATEWAY_ACTION in obs.observation.available_actions:
                if current_minerals >= 150:
                    # 計算傳送門位置：以第一個 Pylon 為基準
                    if self.pylon_target_a:
                        px, py = self.pylon_target_a
                        # 增加 Y 軸偏移量至 12 (避免重疊)
                        # 如果 Pylon 在上半部 (y < 42)，往下蓋 (+12)；否則往上蓋 (-12)
                        offset_gateway_y = 12 if py < 42 else -12
                        
                        # 確保不超出邊界
                        target_x = np.clip(px, 0, 83) 
                        target_y = np.clip(py + offset_gateway_y, 0, 83)
                        
                        target = (target_x, target_y)
                        
                        self.state = 6.05
                        self.select_attempts = 0
                        print(f"[{self}] 執行建造 Gateway (座標: {target})")
                        return actions.FUNCTIONS.Build_Gateway_screen("now", target)
            else:
                 return get_select_probe_action()
        
        elif self.state == 6.05:
            # 狀態 6.05: 排程讓蓋建築的工兵回去採瓦斯
            if HARVEST_ACTION in obs.observation.available_actions and self.assimilator_target:
                self.state = 6.1
                print(f"[{self}] 排程建築工兵返回瓦斯廠 (Queued)")
                return actions.FUNCTIONS.Harvest_Gather_screen("queued", self.assimilator_target)
            
            # 如果無法排程(例如沒選到)，直接跳過
            self.state = 6.1
            return NO_OP

        elif self.state == 6.1:
             # 狀態 6.1: 等待傳送門出現
             if count_units(GATEWAY_ID) > 0:
                 self.state = 7
                 print(f"[{self}] Gateway 建造中，準備建造機械控制核心")
                 return NO_OP
             
             self.select_attempts += 1
             if self.select_attempts > 20:
                 self.state = 6
                 return NO_OP

        elif self.state == 7:
            # 狀態 7: 建造機械控制核心 (Cybernetics Core)
            # 需要 150 礦 (需要 Gateway)
            if BUILD_CYBERNETICS_CORE_ACTION in obs.observation.available_actions:
                if current_minerals >= 150:
                    # 位置：在 Pylon A 附近找個位置
                    if self.pylon_target_a:
                        px, py = self.pylon_target_a
                        
                        # 增加 X 軸偏移量至 12 (避免重疊)
                        # 如果 Pylon 在左半邊 (px < 42)，往右蓋 (+12)；否則往左蓋 (-12)
                        offset_cyber_x = 12 if px < 42 else -12
                        
                        target_x = np.clip(px + offset_cyber_x, 0, 83)
                        target_y = np.clip(py, 0, 83) # 保持 Y 軸與 Pylon 相同
                        
                        target = (target_x, target_y)
                        
                        self.state = 7.05
                        self.select_attempts = 0
                        print(f"[{self}] 執行建造 Cybernetics Core (座標: {target})")
                        return actions.FUNCTIONS.Build_CyberneticsCore_screen("now", target)
            else:
                return get_select_probe_action()

        elif self.state == 7.05:
            # 狀態 7.05: 排程採集
            if HARVEST_ACTION in obs.observation.available_actions and self.assimilator_target:
                self.state = 7.1
                print(f"[{self}] 排程建築工兵返回瓦斯廠 (Queued)")
                return actions.FUNCTIONS.Harvest_Gather_screen("queued", self.assimilator_target)
            self.state = 7.1
            return NO_OP

        elif self.state == 7.1:
            # 狀態 7.1: 等待機械控制核心完成
            if count_units(CYBERNETICS_CORE_ID) > 0:
                 self.state = 8
                 self.stalkers_trained = 0
                 print(f"[{self}] Cybernetics Core 建造中，進入狀態 8: 準備生產追獵者")
                 return NO_OP
            
            self.select_attempts += 1
            # 增加超時時間，給予工兵更多時間走到目標位置 (80幀約5秒)
            if self.select_attempts > 80:
                self.state = 7
                return NO_OP

        elif self.state == 8:
            # 狀態 8: 生產 5 隻追獵者
            if self.stalkers_trained < 5:
                if TRAIN_STALKER_ACTION in obs.observation.available_actions:
                    if current_minerals >= 125 and current_vespene >= 50:
                        # 追獵者佔 2 人口
                        if current_supply_cap - current_workers - self.stalkers_trained * 2 >= 2:
                            self.stalkers_trained += 1
                            print(f"[{self}] 訓練追獵者 {self.stalkers_trained}/5")
                            return actions.FUNCTIONS.Train_Stalker_quick("now")
                    return NO_OP
                else:
                    return get_select_gateway_action()
            else:
                # 5 隻完成，進入進攻階段
                self.state = 9
                print(f"[{self}] 5 隻追獵者訓練完成，準備進攻！")
                return NO_OP

        elif self.state == 9:
            # 狀態 9：先選取全部我方軍隊
            if self.enemy_minimap_coords is None:
                # 還不知道敵人在哪，就先不要動
                return NO_OP

            self.state = 10
            return select_all_army()

        elif self.state == 10:
            # 狀態 10：對敵方位置下 Attack_minimap
            if self.enemy_minimap_coords is None:
                return NO_OP

            if actions.FUNCTIONS.Attack_minimap.id in obs.observation.available_actions:
                print(f"[{self}] 下達進攻命令，目標 minimap: {self.enemy_minimap_coords}")
                return actions.FUNCTIONS.Attack_minimap("now", self.enemy_minimap_coords)

            # 如果還沒選到兵，回去再選一次
            self.state = 9
            return NO_OP

        return NO_OP

class TerranBot:
    """人族自動化機器人邏輯封裝 (簡易版: 採礦 -> 造 SCV -> 補給站 -> 瓦斯 -> 採氣)"""
    def __init__(self):
        self.state = -1
        self.supply_depot_target = None
        self.refinery_target = None
        self.barracks_target = None
        self.gas_workers_assigned = 0
        self.marauders_trained = 0     # 新增：已訓練的掠奪者數量
        self.selecting_worker = True
        self.recent_selected_coords = []
        self.busy_depot_locations = [] # 新增：記錄正在施工的地點
        self.depots_built = 0          # 新增：已建造的補給站數量
        self.last_depot_pixels = 0     # 新增：記錄上一次的補給站像素量
        self.select_attempts = 0
        self.initial_mineral_coords = None
        self.first_depot_coords = None # 新增：記錄第一個補給站的位置，用於計算三角形
        self.build_dir = (1, 1)        # 新增：記錄建造方向
        self.base_minimap_coords = None # 新增：記錄基地在小地圖的位置
        self.cc_x_screen = 0
        self.cc_y_screen = 0
        self.camera_centered = False   # 新增：記錄是否已移動鏡頭
        self.is_first_step = True
        self.enemy_minimap_coords = None
        self.own_minimap_coords = None
        self.form_active = False
        self.form_type = None          # 新增
        self.form_queue = []           # 新增
        self.form_idx = 0              # 新增
        self.form_cooldown = 0         # 新增
    
    def _start_marauder_formation(self, unit_type_screen, form_type):
        marauders = self._get_5_marauder_points(unit_type_screen)
        if len(marauders) < 5:
            return False

        marauders = sorted(marauders, key=lambda p: p[0])
        cx = int(round(sum([p[0] for p in marauders]) / 5))
        cy = int(round(sum([p[1] for p in marauders]) / 5))
        center = self._clip(cx, cy)

        slots = self._build_slots_marauder(form_type, center)

        self.form_active = True
        self.form_type = form_type
        self.form_queue = list(zip(marauders, slots))
        self.form_idx = 0
        self.form_cooldown = 16
        return True

    def step(self, obs):
        unit_type_screen = obs.observation.feature_screen[features.SCREEN_FEATURES.unit_type.index]
        current_supply_cap = obs.observation.player.food_cap
        current_minerals = obs.observation.player.minerals
        current_vespene = obs.observation.player.vespene
        current_workers = obs.observation.player.food_workers

        # --- minimap 上找自己跟敵人 ---
        player_relative_mini = obs.observation.feature_minimap[features.MINIMAP_FEATURES.player_relative.index]
        y_self, x_self = (player_relative_mini == features.PlayerRelative.SELF).nonzero()
        if x_self.any():
            self.own_minimap_coords = (int(x_self.mean()), int(y_self.mean()))

        y_enemy, x_enemy = (player_relative_mini == features.PlayerRelative.ENEMY).nonzero()
        if x_enemy.any():
            self.enemy_minimap_coords = (int(x_enemy.mean()), int(y_enemy.mean()))


        # --- 輔助函式 ---
        def count_units(unit_id):
            return np.sum((unit_type_screen == unit_id).astype(int))

        def get_select_cc_action():
            y_coords, x_coords = (unit_type_screen == COMMAND_CENTER_ID).nonzero()
            if x_coords.any():
                target_x = int(x_coords.mean())
                target_y = int(y_coords.mean())
                self.cc_x_screen = target_x
                self.cc_y_screen = target_y
                return actions.FUNCTIONS.select_point("select", (target_x, target_y))
            return NO_OP

        def get_select_scv_action(select_type="select"):
            y_coords, x_coords = (unit_type_screen == SCV_ID).nonzero()
            if x_coords.any():
                # 過濾條件 1: 正在建造補給站的 (避開 busy_depot_locations)
                mask = np.ones(len(x_coords), dtype=bool) # 初始為全 True
                
                for busy_x, busy_y in self.busy_depot_locations:
                    dist_busy = np.sqrt((x_coords - busy_x)**2 + (y_coords - busy_y)**2)
                    mask = mask & (dist_busy > 10) # 距離大於10才選

                # 過濾條件 2: 正在建造當前目標的 (避開 supply_depot_target, 如果有)
                if self.supply_depot_target:
                    dist_target = np.sqrt((x_coords - self.supply_depot_target[0])**2 + (y_coords - self.supply_depot_target[1])**2)
                    mask = mask & (dist_target > 10)

                # 過濾條件 3: 已經去採瓦斯的 (避開 refinery_target, 如果有)
                if self.refinery_target:
                    dist_gas = np.sqrt((x_coords - self.refinery_target[0])**2 + (y_coords - self.refinery_target[1])**2)
                    mask = mask & (dist_gas > 15) # 瓦斯廠距離要更寬鬆一點

                if mask.any():
                    # 修改：隨機選取一個符合條件的 SCV，避免一直選到同一隻卡住的
                    valid_indices = np.where(mask)[0]
                    idx = random.choice(valid_indices)
                    target_x, target_y = int(x_coords[idx]), int(y_coords[idx])
                    return actions.FUNCTIONS.select_point(select_type, (target_x, target_y))
                
                # Fallback: 隨機選一個
                idx = random.randint(0, len(x_coords) - 1)
                target_x, target_y = int(x_coords[idx]), int(y_coords[idx]) 
                return actions.FUNCTIONS.select_point(select_type, (target_x, target_y))
            return NO_OP
        
        def get_select_barracks_action():
            y_coords, x_coords = (unit_type_screen == BARRACKS_ID).nonzero()
            if x_coords.any():
                target_x = int(x_coords.mean())
                target_y = int(y_coords.mean())
                return actions.FUNCTIONS.select_point("select", (target_x, target_y))
            return NO_OP
        
        def select_all_army():
            player_relative_screen = obs.observation.feature_screen[features.SCREEN_FEATURES.player_relative.index]
            ys, xs = (player_relative_screen == features.PlayerRelative.SELF).nonzero()
            if xs.any():
                x_min, x_max = int(xs.min()), int(xs.max())
                y_min, y_max = int(ys.min()), int(ys.max())
                return actions.FUNCTIONS.select_rect("select", (x_min, y_min), (x_max, y_max))
            return NO_OP


        # --- 初始化 ---
        if self.is_first_step:
            self.is_first_step = False
            mineral_coords = (unit_type_screen == MINERAL_FIELD_ID).nonzero()
            if mineral_coords[0].any():
                self.initial_mineral_coords = (mineral_coords[1][0], mineral_coords[0][0])
            else:
                print("[Terran] Warning: No minerals found at start!")

            cc_coords = (unit_type_screen == COMMAND_CENTER_ID).nonzero()
            if cc_coords[0].any():
                self.cc_x_screen = int(cc_coords[1].mean())
                self.cc_y_screen = int(cc_coords[0].mean())
            
            # 儲存小地圖上的基地位置
            player_relative = obs.observation.feature_minimap[features.MINIMAP_FEATURES.player_relative.index]
            y_mini, x_mini = (player_relative == features.PlayerRelative.SELF).nonzero()
            if x_mini.any():
                self.base_minimap_coords = (int(x_mini.mean()), int(y_mini.mean()))
            
            # 初始化像素計數
            self.last_depot_pixels = count_units(SUPPLY_DEPOT_ID)



        # cooldown
        if self.form_cooldown > 0:
            self.form_cooldown -= 1

        # if forming: one unit per step
        if self.form_active:
            if self.form_idx >= len(self.form_queue):
                self.form_active = False
            else:
                (sx, sy), (tx, ty) = self.form_queue[self.form_idx]

                if actions.FUNCTIONS.select_point.id in obs.observation.available_actions:
                    return actions.FUNCTIONS.select_point("select", (sx, sy))

                if actions.FUNCTIONS.Attack_screen.id in obs.observation.available_actions:
                    self.form_idx += 1
                    return actions.FUNCTIONS.Attack_screen("now", (tx, ty))

                return NO_OP
        
        # --- 狀態機 ---
        if self.state == -1:
            # 狀態 -1: 開局採礦
            if HARVEST_ACTION in obs.observation.available_actions and self.initial_mineral_coords:
                self.state = 0
                return actions.FUNCTIONS.Harvest_Gather_screen("now", self.initial_mineral_coords)
            else:
                return get_select_scv_action("select_all_type")

        elif self.state == 0:
            # 狀態 0: 生產 SCV 直到 15
            if current_workers < 15:
                if TRAIN_SCV_ACTION in obs.observation.available_actions:
                    if current_minerals >= 50:
                        return actions.FUNCTIONS.Train_SCV_quick("now")
                elif current_minerals >= 50:
                    return get_select_cc_action() 
            elif current_minerals >= 100:
                self.state = 1
                # 計算第一個補給站位置 (修改：偏移量更小，更靠近主堡)
                offset_x = 15 if self.initial_mineral_coords[0] < self.cc_x_screen else -15
                offset_y = 15 if self.initial_mineral_coords[1] < self.cc_y_screen else -15
                self.supply_depot_target = (
                    np.clip(self.cc_x_screen + offset_x, 0, 83).astype(int),
                    np.clip(self.cc_y_screen + offset_y, 0, 83).astype(int)
                )
                
                # 記錄第一個補給站的資訊以供後續計算三角形
                self.first_depot_coords = self.supply_depot_target
                dir_x = 1 if offset_x > 0 else -1
                dir_y = 1 if offset_y > 0 else -1
                self.build_dir = (dir_x, dir_y)
                
                print(f"[Terran] 準備建造第 1 個 Supply Depot: {self.supply_depot_target}")
                return get_select_scv_action()
            
            return NO_OP

        elif self.state == 1:
            # 狀態 1: 建造補給站 (循環直到蓋滿 3 個)
            if BUILD_SUPPLYDEPOT_ACTION in obs.observation.available_actions:
                if current_minerals >= 100:
                    self.state = 1.1
                    self.select_attempts = 0 # 重置超時計數
                    return actions.FUNCTIONS.Build_SupplyDepot_screen("now", self.supply_depot_target)
            else:
                # 確保有錢才選工兵
                if current_minerals >= 100:
                    return get_select_scv_action()
                return NO_OP

        elif self.state == 1.1:
            # 狀態 1.1: 等待新的補給站開始建造
            current_pixels = count_units(SUPPLY_DEPOT_ID)
            
            if current_pixels > self.last_depot_pixels + 5: # 降低閾值以防萬一
                self.depots_built += 1
                self.last_depot_pixels = current_pixels
                self.busy_depot_locations.append(self.supply_depot_target)
                print(f"[Terran] 第 {self.depots_built} 個 Supply Depot 開始建造 (成功)")

                if self.depots_built < 3:
                    # 計算下一個目標位置 (三角形排列)
                    dir_x, dir_y = self.build_dir
                    base_x, base_y = self.first_depot_coords
                    
                    if self.depots_built == 1:
                        # 第 2 個：蓋在第 1 個的水平旁邊
                        next_x = base_x + (12 * dir_x)
                        next_y = base_y
                    else:
                        # 第 3 個：蓋在中間垂直方向 (形成三角形)
                        # X 軸取中間 (+6)，Y 軸往外延伸 (+12)
                        next_x = base_x + (6 * dir_x)
                        next_y = base_y + (12 * dir_y)
                    
                    self.supply_depot_target = (
                        np.clip(next_x, 0, 83).astype(int), 
                        np.clip(next_y, 0, 83).astype(int)
                    )
                    
                    self.state = 1
                    print(f"[Terran] 準備建造第 {self.depots_built + 1} 個 Supply Depot (三角形): {self.supply_depot_target}")
                    return get_select_scv_action() 
                else:
                    self.state = 2
                    print(f"[Terran] 3 個補給站已安排，準備建造 Refinery")
                    return NO_OP
            
            # 超時重試機制
            self.select_attempts += 1
            if self.select_attempts > 100: # 約 6-7 秒
                print(f"[Terran] 建造補給站超時/失敗，嘗試更換位置重試")
                old_x, old_y = self.supply_depot_target
                # 大幅度更換位置
                self.supply_depot_target = (
                    np.clip(old_x + random.randint(-15, 15), 0, 83), 
                    np.clip(old_y + random.randint(-15, 15), 0, 83)
                )
                self.state = 1 # 重試
                return get_select_scv_action() # 換個工兵試試

            return NO_OP

        elif self.state == 2:
            # 狀態 2: 建造 Refinery
            if BUILD_REFINERY_ACTION in obs.observation.available_actions:
                if current_minerals >= 75:
                    if self.refinery_target is None:
                        y_geo, x_geo = (unit_type_screen == GEYSER_ID).nonzero()
                        if x_geo.any():
                             first_x, first_y = x_geo[0], y_geo[0]
                             mask = (np.abs(x_geo - first_x) < 10) & (np.abs(y_geo - first_y) < 10)
                             target_x = int(x_geo[mask].mean())
                             target_y = int(y_geo[mask].mean())
                             self.refinery_target = (target_x, target_y)
                        else:
                             print("[Terran] 找不到瓦斯噴泉")
                             return NO_OP
                    
                    self.state = 2.1
                    print(f"[Terran] 建造 Refinery")
                    return actions.FUNCTIONS.Build_Refinery_screen("now", self.refinery_target)
            else:
                return get_select_scv_action()

        elif self.state == 2.1:
            # 狀態 2.1: 等待 Refinery
            if count_units(REFINERY_ID) > 0:
                self.state = 3
                self.gas_workers_assigned = 0
                self.selecting_worker = True
                self.recent_selected_coords = []
                print(f"[Terran] Refinery 完成，開始採集瓦斯")
                return NO_OP
            return NO_OP

        elif self.state == 3:
            # 狀態 3: 指派 3 隻 SCV 採瓦斯
            if self.gas_workers_assigned < 3:
                if self.selecting_worker:
                    y_coords, x_coords = (unit_type_screen == SCV_ID).nonzero()
                    if x_coords.any():
                        distances = np.sqrt((x_coords - self.refinery_target[0])**2 + (y_coords - self.refinery_target[1])**2)
                        mask = distances > 15 
                        
                        for past_x, past_y in self.recent_selected_coords:
                            dist_from_past = np.sqrt((x_coords - past_x)**2 + (y_coords - past_y)**2)
                            mask = mask & (dist_from_past > 5)

                        if mask.any():
                            valid_x = x_coords[mask]
                            valid_y = y_coords[mask]
                            idx = random.randint(0, len(valid_x) - 1)
                            target_x, target_y = int(valid_x[idx]), int(valid_y[idx])
                            self.recent_selected_coords.append((target_x, target_y))
                            self.selecting_worker = False
                            return actions.FUNCTIONS.select_point("select", (target_x, target_y))
                        
                        # Fallback
                        idx = random.randint(0, len(x_coords) - 1)
                        target_x, target_y = int(x_coords[idx]), int(y_coords[idx])
                        self.recent_selected_coords.append((target_x, target_y))
                        self.selecting_worker = False
                        return actions.FUNCTIONS.select_point("select", (target_x, target_y))
                    return NO_OP
                else:
                    if HARVEST_ACTION in obs.observation.available_actions:
                        self.gas_workers_assigned += 1
                        self.selecting_worker = True
                        print(f"[Terran] 指派 SCV {self.gas_workers_assigned}/3 採瓦斯")
                        return actions.FUNCTIONS.Harvest_Gather_screen("now", self.refinery_target)
                    else:
                        self.selecting_worker = True
                        return NO_OP
            else:
                self.state = 4
                print("[Terran] 瓦斯採集指派完成，準備建造兵營")
                return NO_OP
        
        elif self.state == 4:
            # 狀態 4: 建造兵營 (Barracks)
            
            # 1. 確保取得基地在小地圖的位置 (用於移動鏡頭 & 判斷建造方向)
            if self.base_minimap_coords is None:
                # 使用 player_relative (1=SELF) 來找自己單位在小地圖的重心，比找特定單位ID更穩健
                player_relative = obs.observation.feature_minimap[features.MINIMAP_FEATURES.player_relative.index]
                y_mini, x_mini = (player_relative == features.PlayerRelative.SELF).nonzero()
                
                if x_mini.any():
                    self.base_minimap_coords = (int(x_mini.mean()), int(y_mini.mean()))
                    print(f"[Terran] 偵測到基地位置 (Minimap): {self.base_minimap_coords}")
                else:
                    # 萬一完全找不到自己單位(不太可能)，預設為左上 (15, 15)
                    self.base_minimap_coords = (15, 15)
                    print("[Terran] 警告：無法在小地圖偵測到單位，預設為左上出生")

            # 2. 移動鏡頭 (只做一次)
            if not self.camera_centered:
                target_x, target_y = self.base_minimap_coords
                print(f"[Terran] 移動鏡頭至: ({target_x}, {target_y})")
                self.camera_centered = True
                # 修正：只傳入座標參數，不傳入排程參數
                return actions.FUNCTIONS.move_camera((target_x, target_y))
            
            # 3. 執行建造指令 (鏡頭已移動，主堡應在畫面中心)
            if BUILD_BARRACKS_ACTION in obs.observation.available_actions:
                if current_minerals >= 150:
                    if self.barracks_target is None:
                        # 判斷出生點：根據小地圖 X 座標
                        minimap_x = self.base_minimap_coords[0]
                        
                        # 預設偏移 (左上出生 -> 往右)
                        offset_x = 30 
                        offset_y = 0
                        
                        # 如果在右半邊 (X > 32)，則是右下出生 -> 往左
                        if minimap_x > 32:
                            offset_x = -30
                            # offset_y 維持 0 或視情況調整
                        
                        # 加入隨機偏移
                        rand_off_x = random.randint(-5, 5)
                        rand_off_y = random.randint(-5, 5)

                        # 畫面中心是 (42, 42)
                        self.barracks_target = (
                            np.clip(42 + offset_x + rand_off_x, 0, 83).astype(int),
                            np.clip(42 + offset_y + rand_off_y, 0, 83).astype(int)
                        )
                        print(f"[Terran] 計算兵營座標: 基地X={minimap_x}, 偏移={offset_x}, 目標={self.barracks_target}")

                    self.state = 4.1
                    self.select_attempts = 0
                    return actions.FUNCTIONS.Build_Barracks_screen("now", self.barracks_target)
            else:
                return get_select_scv_action()

        elif self.state == 4.1:
             # 狀態 4.1: 等待 Barracks 建造開始
             if count_units(BARRACKS_ID) > 0:
                 self.state = 5
                 print(f"[Terran] Barracks 建造中，準備建造科技實驗室")
                 return NO_OP
             
             # 超時重試
             self.select_attempts += 1
             if self.select_attempts > 100:
                 self.state = 4
                 self.barracks_target = None
                 return NO_OP
                 
             return NO_OP

        elif self.state == 5:
            # 狀態 5: 建造科技實驗室 (Tech Lab)
            # 檢查是否已有 Tech Lab (避免重複建造)
            if count_units(BARRACKS_TECHLAB_ID) > 0:
                self.state = 7 # 直接跳到生產
                print("[Terran] Tech Lab 已存在，跳轉至生產")
                return NO_OP

            # 需要選取已完成的 Barracks
            if BUILD_TECHLAB_ACTION in obs.observation.available_actions:
                if current_minerals >= 50 and current_vespene >= 25:
                    self.state = 6 # 注意: 進入 State 6 等待 Tech Lab
                    print(f"[Terran] 建造 Tech Lab")
                    return actions.FUNCTIONS.Build_TechLab_quick("now")
            else:
                # 嘗試選取 Barracks
                return get_select_barracks_action()
            
            return NO_OP

        elif self.state == 6:
            # 狀態 6: 等待 Tech Lab 完成
            if count_units(BARRACKS_TECHLAB_ID) > 0:
                self.state = 7
                print("[Terran] Tech Lab 建造完成，準備生產掠奪者")
                return NO_OP
            return NO_OP

        elif self.state == 7:
            # 狀態 7: 生產 5 隻掠奪者 (Marauder)
            if self.marauders_trained < 5:
                if TRAIN_MARAUDER_ACTION in obs.observation.available_actions:
                    if current_minerals >= 100 and current_vespene >= 25:
                        if current_supply_cap - current_workers - self.marauders_trained * 2 >= 2:
                            self.marauders_trained += 1
                            print(f"[Terran] 訓練掠奪者 {self.marauders_trained}/5")
                            return actions.FUNCTIONS.Train_Marauder_quick("now")
                    return NO_OP
                else:
                    return get_select_barracks_action()
            else:
                self.state = 8
                print("[Terran] 5 隻掠奪者訓練完成，準備進攻！")
                return NO_OP

        elif self.state == 8:
            # 狀態 8：準備進攻（這裡決定要不要先排陣）
            if self.enemy_minimap_coords is None:
                return NO_OP

            # ======【第 4 步：觸發三陣型】======
            # 條件：沒在排陣、冷卻結束、敵人位置已知
            if (not self.form_active) and self.form_cooldown == 0:
                # 用 minimap 距離決定陣型（不用 import math）
                dx = self.enemy_minimap_coords[0] - self.own_minimap_coords[0]
                dy = self.enemy_minimap_coords[1] - self.own_minimap_coords[1]
                d2 = dx*dx + dy*dy

                # 你可微調門檻：
                # d2 <= 100 代表距離 <= 10
                # d2 <= 400 代表距離 <= 20
                if d2 <= 100:
                    desired = "SPREAD"
                elif d2 <= 400:
                    desired = "CONCAVE"
                else:
                    desired = "LINE"

                ok = self._start_marauder_formation(unit_type_screen, desired)
                if ok:
                    print(f"[Terran] 觸發陣型：{desired}，開始排陣")
                    return NO_OP  # 下一回合會由「第 3 步」逐隻排陣
            # ======【第 4 步結束】======

            # 若沒觸發排陣，才照你原本流程：先全選軍隊再進攻
            self.state = 9
            return select_all_army()

        elif self.state == 9:
            # 狀態 9：Attack_minimap 到敵人
            if self.enemy_minimap_coords is None:
                return NO_OP

            if actions.FUNCTIONS.Attack_minimap.id in obs.observation.available_actions:
                print(f"[Terran] 下達進攻命令，目標 minimap: {self.enemy_minimap_coords}")
                return actions.FUNCTIONS.Attack_minimap("now", self.enemy_minimap_coords)

            # 沒選到兵就回去再選一次
            self.state = 8
            return NO_OP

        return NO_OP
    
    def _clip(self, x, y, lo=0, hi=83):
        return (int(np.clip(x, lo, hi)), int(np.clip(y, lo, hi)))

    def _connected_centroids(self, mask_bool):
        """mask_bool: (84,84) bool -> 回傳每個連通區的 centroid (x,y)"""
        h, w = mask_bool.shape
        seen = np.zeros((h, w), dtype=np.uint8)
        cents = []
        for y in range(h):
            for x in range(w):
                if not mask_bool[y, x] or seen[y, x]:
                    continue
                stack = [(x, y)]
                seen[y, x] = 1
                pix = []
                while stack:
                    px, py = stack.pop()
                    pix.append((px, py))
                    for nx, ny in ((px-1,py),(px+1,py),(px,py-1),(px,py+1)):
                        if 0 <= nx < w and 0 <= ny < h and mask_bool[ny, nx] and not seen[ny, nx]:
                            seen[ny, nx] = 1
                            stack.append((nx, ny))
                xs = [p[0] for p in pix]
                ys = [p[1] for p in pix]
                cents.append((int(round(sum(xs)/len(xs))), int(round(sum(ys)/len(ys)))))
        return cents

    def _get_5_marauder_points(self, unit_type_screen):
        mask = (unit_type_screen == MARAUDER_ID)
        pts = self._connected_centroids(mask)
        pts = sorted(pts, key=lambda p: (p[0], p[1]))
        return pts[:5]

    
    def _dir_and_perp(self):
    # 用 minimap enemy/self 決定面向；沒敵人就往上
        if getattr(self, "own_minimap_coords", None) and getattr(self, "enemy_minimap_coords", None):
            dx = self.enemy_minimap_coords[0] - self.own_minimap_coords[0]
            dy = self.enemy_minimap_coords[1] - self.own_minimap_coords[1]
            dx = 0 if dx == 0 else (1 if dx > 0 else -1)
            dy = 0 if dy == 0 else (1 if dy > 0 else -1)
        else:
            dx, dy = 0, -1
        perp = (-dy, dx)
        return (dx, dy), perp

    def _build_slots_marauder(self, form_type, center_xy):
        cx, cy = center_xy
        (dx, dy), (px, py) = self._dir_and_perp()

        if form_type == "LINE":
            # ○ ○ ○ ○ ○（較密）
            s = 6
            offsets = [(-2*s, 0), (-s, 0), (0, 0), (s, 0), (2*s, 0)]
            slots = [(cx + ox*px + oy*dx, cy + ox*py + oy*dy) for (ox, oy) in offsets]

        elif form_type == "SPREAD":
            # 更分散
            s = 8
            offsets = [(-2*s, 0), (-s, 0), (0, 0), (s, 0), (2*s, 0)]
            slots = [(cx + ox*px + oy*dx, cy + ox*py + oy*dy) for (ox, oy) in offsets]

        else:  # "CONCAVE"
            # 兩翼前、三隻後（凹形面向敵人）
            s = 6
            offsets = [(-2*s, +s), (2*s, +s), (-s, -s), (0, -s), (s, -s)]
            slots = [(cx + ox*px + oy*dx, cy + ox*py + oy*dy) for (ox, oy) in offsets]

        slots = [self._clip(x, y) for (x, y) in slots]
        return sorted(slots, key=lambda p: p[0])

def main(argv):
    del argv
    
    # 建立兩個機器人實例
    bot1 = ProtossBot()
    bot2 = TerranBot() # Player 2 改為人族機器人

    with sc2_env.SC2Env(
        map_name="Simple64",
        players=[
            sc2_env.Agent(sc2_env.Race.protoss), # 玩家 1 (Agent)
            sc2_env.Agent(sc2_env.Race.terran)   # 玩家 2 (Agent) - 改為人族
        ],
        agent_interface_format=sc2_env.AgentInterfaceFormat(
            feature_dimensions=sc2_env.Dimensions(screen=84, minimap=64),
            use_raw_units=False, 
        ),
        step_mul=16, 
        realtime=False,
        visualize=True
    ) as env:

        # 重置環境，取得雙方的初始觀察值
        # obs_list[0] 是玩家 1 的觀察，obs_list[1] 是玩家 2 的觀察
        obs_list = env.reset() 
        
        # 讓兩個機器人各自初始化
        bot1.step(obs_list[0])
        bot2.step(obs_list[1])

        for i in range(5000):
            actions_list = []
            
            # 1. 取得 Player 1 的動作
            action1 = bot1.step(obs_list[0])
            actions_list.append(action1)
            
            # 2. 取得 Player 2 的動作
            action2 = bot2.step(obs_list[1])
            actions_list.append(action2)
            
            # 3. 將動作列表傳送給環境執行 (必須包含雙方動作)
            try:
                obs_list = env.step(actions_list)
            except Exception as e:
                print(f"執行錯誤: {e}")
                break
            
            # 顯示狀態資訊 (每50步)
            if i % 50 == 0:
                # 這裡只印出 bot1 的狀態作為代表，避免洗版
                print(f"Step {i} | Bot1 State: {bot1.state} | Bot2 State: {bot2.state}")

if __name__ == "__main__":
    app.run(main)